#! /usr/bin/env python
#
# Network scheme-setting tool
# Copyright 2010-2016 by Akkana Peck akkana@shallowsky.com
# ... share and enjoy under the GPLv2 or (at your option) later.
#

import sys, os
import pwd
import subprocess
import signal
import re
import shutil
import tempfile
import time
from ConfigParser import ConfigParser
import socket    # for socket.gethostname()
import urllib2

# Only for debugging
import traceback

import netutils

def pathsplit(path):
    '''Split a path into all its components -- not just splitting off
       the last like os.path.split.
       If the path is absolute (starts with /) then the first
       component will be /.
    '''
    p = []
    while path:
        newpath, last = os.path.split(path)
        if newpath == '/':
            if last:
                p.insert(0, last)
            p.insert(0, newpath)
            break
        p.insert(0, last)
        path = newpath
    return p

class NetScheme:
    """A network scheme, either wired or wireless.
       encryption=None means wired;
       wireless schemes will have encryption in ( "open", "wep", "wpa" )
       The other arguments should be self-explanatory.
    """
    configdir = None

    def __init__(self, name, dhcp=True,
                 ip='', netmask='', broadcast='', gateway='',
                 encryption='', essid='', key='', dns_servers=''):
        self.name = name
        self.essid = essid
        self.dhcp = dhcp
        if ip == 'host':
            # Set the static IP for this scheme to the IP in /etc/hosts
            # corresponding to our current hostname:
            self.ip = NetScheme.get_ip_from_hostname()
        else:
            self.ip = ip
        self.netmask = netmask
        self.broadcast = broadcast
        self.gateway = gateway
        if encryption:
            self.encryption = encryption.lower()
        else:
            self.encryption = None
        self.key = key
        if not dns_servers or dns_servers == '' or \
                (len(dns_servers) == 1 and dns_servers[0] == ''):
            self.dns_servers = None
        else:
            self.dns_servers = dns_servers
        self.iface = None

        # Sanity check: if there's an essid then encryption should be set
        if self.essid and not self.encryption:
            self.encryption = "open"

    @classmethod
    def get_ip_from_hostname(cls):
        hostname = socket.gethostname()
        for line in open('/etc/hosts'):
            groups = line.split()
            if hostname in groups[1:]:
                return groups[0]
        return None
    # XXX This should cache the result so it only has to be done once.

    def __repr__(self):
        s = "[%s]" % (self.name)
        if self.dhcp:
            s += "\ndhcp = true"
        else:
            s += "\ndhcp = false"
        if self.essid:
            s += "\nessid = %s" % (self.essid)
        if self.ip:
            s += "\nip = %s" % (self.ip)
        if self.netmask:
            s += "\nnetmask = %s" % (self.netmask)
        if self.broadcast:
            s += "\nbroadcast = %s" % (self.broadcast)
        if self.gateway:
            s += "\ngateway = %s" % (self.gateway)
        if self.encryption:
            s += "\nencryption = %s" % (self.encryption)
        if self.key:
            s += "\nkey = %s" % (self.key)
        if self.dns_servers:
            s += "\ndns_servers = %s" % (self.dns_servers)
            # XXX Probably need to print the [ list ]
        # Don't save the interface, but the user might change it:
        #if self.interface:
        #    s += "\ninterface = %s" % (self.interface)

        return s

    @classmethod
    def schemedirfile(cls, filename, create=False):
        '''Return the name of a file (.netscheme, current) in our config dir.
           If create is true, create the directory and file
           (and chown if needed) if it doesn't already exist.
        '''

        if not NetScheme.configdir:
            # Get the homedir for the user running this script,
            # if we haven't already.
            # Alasy, if it's run under sudo, ~ and $HOME may expand to root
            # rather than to the actual user. This is a configurable sudo option
            # and varies randomly among distros.
            sudo_user = os.getenv("SUDO_USER")
            if sudo_user:
                home = os.path.expanduser("~" + sudo_user)
            else:
                home = os.path.expanduser("~")

            NetScheme.configdir = os.path.join(home, ".config", "netscheme")

        if filename:
            configfile = os.path.join(NetScheme.configdir, filename)
        else:
            configfile = NetScheme.configdir

        # If the directory already exists and we don't need to create
        # a new file (just the directory itself), we're done.
        if os.path.exists(configfile) or not create:
            # print "Don't need to create the file -- returning"
            return configfile

        # Create was specified, and at least some components of the path
        # don't exist and need to be created and possibly chowed.
        # For that, we'll need to know the original user, before sudo.
        if sudo_user:
            pw = pwd.getpwnam(sudo_user)
            uid = pw.pw_uid
        else:
            uid = os.getuid()

        # Get the part of the path inside the user's homedir.
        # We don't want to create anything above the homedir level.
        if not NetScheme.configdir.startswith(home):
            print "Confusion! config dir %s isn't inside homedir %s" \
                % (NetScheme.configdir, home)
            return
        reldir = NetScheme.configdir[len(home)+1:]
        pathcomp = pathsplit(reldir)
        homepath = home
        try:
            for comp in pathcomp:
                homepath = os.path.join(homepath, comp)
                if not os.path.exists(homepath):
                    print "Creating", homepath
                    os.mkdir(homepath)
                    if sudo_user:
                        print "chowning", homepath
                        os.chown(homepath, uid, -1)
                    if homepath != NetScheme.configdir:
                        print "Eek -- after creating, %s != %s" \
                            % (homepath, configfile)

        except:
            print "Couldn't create", NetScheme.configdir, "-- using $HOME"
            return home

        # Now we've created and chowned the directory.
        # Do we need to create+chown a file too?
        if not filename:
            return configfile

        # Python seems to have no way to create a file without opening it.
        open(configfile, 'w').close()
        print "Created", configfile, "; sudo_user is", sudo_user
        if sudo_user:
            print "chowning", configfile
            os.chown(configfile, uid, -1)
        else:
            print "no sudo_user"

        return configfile

    def save(self, filename=None):
        if filename:
            filename = NetScheme.schemedirfile(filename, create=True)
            print "Trying to write scheme to", filename
            fp = open(filename, "a")
        else:
            fp = sys.stdout
        print >>fp, ''
        print >>fp, self
        if filename:
            fp.close()

    def set_scheme_debian(self, add):
        """Update /etc/network/interfaces with info for the current scheme.
           If add is true, don't take down any existing interfaces first.
        """

        if not add:
            # First take down any currently up interfaces,
            # or ifup will fail later
            up_ifaces = netutils.get_interfaces(True)
            for i in up_ifaces:
                print "Taking", i, "down with ifdown"
                i.ifconfig_down()
                subprocess.call(["ifdown", i.name])

        if add:
            mode = "a"
        else:
            mode = "w"
        fp = open("/etc/network/interfaces", mode)

        # If we're making a new /etc/network/interfaces,
        # make sure it includes loopback:
        if not add:
            print >>fp, """auto lo
iface lo inet loopback"""

        # Write the entry for the new interface
        print >>fp, """
auto %s""" % (self.iface.name)
        if self.dhcp:
            print >>fp, "iface %s inet dhcp" % (self.iface.name)
        else:
            print >>fp, "iface %s inet static" % (self.iface.name)
            if self.ip:
                print >>fp, "address", self.ip
            if self.netmask:
                print >>fp, "netmask", self.netmask
            if self.broadcast:
                print >>fp, "broadcast", self.broadcast
            if self.gateway:
                print >>fp, "gateway", self.gateway

        print "Encryption:", self.encryption
        if self.encryption == "wpa" or self.encryption == "wpa2":
            if self.essid:
                print >>fp, "wpa-ssid", self.essid
            if self.key:
                print >>fp, "wpa-psk", self.key

        else:
            if self.essid:
                print >>fp, "wireless-essid", self.essid
            if self.key:
                print >>fp, "wireless-key", self.key

        fp.close()
        # Now we have /etc/network/interfaces.

    def set_scheme_manual(self, add):
        """Set the network to use a particular scheme, without needing
           /etc/network/interfaces or other Debian mechanisms.
           If add is true, don't take down any existing interfaces first.
        """

        if not add:
            netutils.ifdown_all()

        self.iface.ifconfig_up()

        if not self.iface.wireless:
            print "It's not wireless"
            pass

        else:
            # If it is wireless, often we try to associate with an AP
            # and it just doesn't work. We loop over that, but if we
            # retry enough times and it still doesn't work, we may
            # need to give up and start over again.
            while True:
                if self.encryption == "wep" or self.encryption == "open":
                    # iwconfig doesn't work reliably on some systems unless you 
                    # specify the MAC address of the accesspoint.
                    # However, this code isn't working on Pangolin, not sure why,
                    # so don't require it.
                    accesspoint = None
                    if self.essid != '':
                        aplist = netutils.get_accesspoints()
                        # The first time, often we get:
                        # SIOCSIFFLAGS: Operation not possible due to RF-kill
                        # get_accesspoints() will return a null list then,
                        # so check for that.
                        if not aplist:
                            continue
                        for ap in aplist:
                            if ap.essid == self.essid:
                                accesspoint = ap
                        # if accesspoint == None:
                        #     print "No accesspoint matching '%s' -- giving up" \
                        #         % (self.essid)
                        #     sys.exit(1)

                    iwargs = ["iwconfig", self.iface.name ]
                    if self.essid:
                        iwargs.append("essid")
                        iwargs.append(self.essid)
                    iwargs.append("mode")
                    iwargs.append("managed")
                    # Don't specify the AP -- that can cause us to get bound
                    # to a bad AP just because it happened to be listed first.
                    # if accesspoint and accesspoint.address:
                    #     iwargs.append("ap")
                    #     iwargs.append(accesspoint.address)
                    if self.key:
                        iwargs.append("key")
                        iwargs.append(self.key)
                    else:
                        iwargs.append("key")
                        iwargs.append("off")
                        #iwargs.append("enc")
                        #iwargs.append("off")
                        iwargs.append("channel")
                        iwargs.append("auto")
                    print "========= Calling", iwargs
                    subprocess.call(iwargs)

                elif self.encryption.startswith("wpa"):
                    tempfp = tempfile.NamedTemporaryFile(prefix="wpasup",
                                                         delete=False)
                    tempname = tempfp.name
                    print "tempname =", tempname
                    print "ssid", self.essid, "key", self.key
                    print >>tempfp, """network={
ssid="%s"
scan_ssid=1
key_mgmt=WPA-PSK
psk="%s"
}""" % (self.essid, self.key)
                    tempfp.close()
                    print "Calling wpa_supplicant -B -Dwext -i", self.iface.name, \
                        "-c", tempname
                    # wpa_supplicant returns in case of error,
                    # but if it succeeds, we need it to keep running.
                    # So we can't use subprocess.call() assuming it will exit.
                    # Instead, use Popen(), wait for a second or two, and
                    # if it's still running, proceed as if things are okay.
                    # If wpa_supplicant exits with nonzero status, assume
                    # it's an error, print it and throw an exception
                    # so the user sees there's a problem (e.g. bad password).
                    rv = subprocess.call(["wpa_supplicant", "wpa_supplicant",
                                          "-B", "-Dwext", "-i", self.iface.name,
                                          "-c", tempname])
                    if rv:
                        print "ERROR! wpa_supplicant returned", rv
                        if rv == 255:
                            print "Maybe password is wrong?"
                        raise OSError

                # If wireless, wait for a connection:
                # If wireless, loop until bound == self.essid,
                # at which point we'll break out of the loop.
                # But only repeat this a few times, then give up
                # and try associating again.
                numtries = 5
                while self.iface.wireless and numtries > 0:
                    bound = None
                    ap = None
                    proc = subprocess.Popen(["iwconfig", self.iface.name],
                                            stdout=subprocess.PIPE)
                    lines = proc.communicate()[0].split('\n')
                    essidpos = lines[0].find('ESSID:')
                    if essidpos >= 0:
                        bound = lines[0][essidpos+6:].strip().strip('"')
                        # strip leading/trailing spaces first, then doublequotes

                    if bound == self.essid:
                        for line in lines[1:]:
                            appos = line.find('Access Point:')
                            if appos >= 0:
                                ap = line[appos+13:].strip()
                                break

                    if bound and (bound == self.essid) \
                            and ap and (not ap.startswith('Not-Associated')):
                        print "We made it! Bound to", self.essid
                        break

                    # It can happen that one of them is an old
                    # ap to which we were previously bound, maybe
                    # because we booted with a persistent scheme
                    # that is no longer here.
                    # Not sure what causes that; possibly a rogue wpasupplicant?
                    elif not bound:
                        print
                        print "Eek! Ww're bound to some other essid,", bound
                        print "Check for a rogue wpasupplicant or something."
                        print

                    print "Not bound to %s yet: '%s, %s'" % (self.essid,
                                                             bound, ap)
                    numtries -= 1
                    time.sleep(2)
                if numtries > 0:
                    break
                else:
                    print "Too many retries: restarting the connection"
                continue

        if self.dhcp:
            print "Getting dhcp"
            try:
                subprocess.check_call(["dhcpcd", "-G", "-C", "resolv.conf",
                                       self.iface.name])
            #except subprocess.CalledProcessError, e:
            except Exception, e:
                print "Couldn't run dhcpcd; trying dhclient"
                try:
                    subprocess.call(["dhclient", "-v", self.iface.name])
                except Exception, e:
                    print "DHCP failed, error", e.returncode
                    self.iface.ifconfig_down()

        else:
            if not self.ip:
                print "Eek -- you need either dhcp or an IP address"
            ifcargs = ["ifconfig", self.iface.name, self.ip]
            if self.netmask:
                ifcargs.append("netmask")
                ifcargs.append(self.netmask)
            if self.broadcast:
                ifcargs.append("broadcast")
                ifcargs.append(self.broadcast)
            subprocess.call(ifcargs)
            if self.gateway:
                r = netutils.Route("default", self.gateway, self.iface.name)
                r.add()
                #subprocess.call(["route", "add", "default", "gw",
                #                 self.gateway])

    # Increasingly, public wifi providers are using idiotic
    # browser authentication that needs to be reset each time.
    # So the net might not really be up. Try to fetch a simple
    # web page and see, and if we're redirected, warn the user.
    # What other clients do:
    #   http://forum.mikrotik.com/viewtopic.php?t=94670#p472054
    def show_browser_if_redirect(self, url, urlcontent):
        """Try to fetch a test URL. If we're redirected to some other URL
           (probably a stupid login page), pop up a browser.
        """
        print "Trying to connect to", url

        request = urllib2.Request(url)
        html = None

        try:
            response = urllib2.urlopen(request, timeout=100)

            # Were we redirected? In theory response.geturl() will tell us that,
            # but in practice, it doesn't, so we have to fetch the content
            # of a page and compare it to the expected value.
            html = response.read()

        # Lots of ways this can fail.
        # e.g. ValueError, "unknown url type"
        # or BadStatusLine: ''
        except urllib2.URLError, e:
            print "urllib2.URLError:", e

        if html == urlcontent:
            print "Looks like we're really connected -- no redirect"
        else:
            print "Couldn't make a test connection -- probably redirected."
            subprocess.call(["quickbrowse", url])

    def set_scheme(self, add=False):
        """Make this scheme active on the current machine.
           If add is true, don't take down any existing interfaces first.
        """

        # Figure out what interface we'll be using:
        self.iface = None
        all = netutils.get_interfaces()
        # Find the last wireless interface if the scheme is wireless,
        # else the last wired.
        # Why last instead of first? Because if the user has a second
        # (e.g. USB) network interface plugged in, it's probably because
        # they need to use that one rather than the built-in interface.
        for i in all:
            # print "Trying interface", i.name
            if i.wireless: print i.name, "is wireless"
            # The clause from hell. What this does is:
            # - If the scheme has an encryption setting (including "open")
            #   then it's a wireless scheme and needs a wireless interface.
            # - In addition, whether it's wired or wireless, if add is true
            #   then we're trying to add an additional interface, so we
            #   can't use any interface that's already up.
            if ((self.encryption and i.wireless) or \
                    (not self.encryption and not i.wireless)) \
                    and (not add or not i.is_up()):
                self.iface = i
                # break
        if not self.iface:
            print "Couldn't find an interface to set the scheme"
            return
        print "Using interface", self.iface

        # Are we on debian?
        is_deb = is_debian()
        if is_deb:
            print "Using Debian-style networking"
            self.set_scheme_debian(add)
        else:
            print "Using standard (non-Debian) network commands"
            self.set_scheme_manual(add)

        # Either way, update resolv.conf if applicable
        if self.dns_servers and len(self.dns_servers) > 0:
            if (add):
                print "Warning: new DNS settings may override old ones"
                print "DNS servers:", self.dns_servers, len(self.dns_servers)
            fp = open("/etc/resolv.conf", "w")
            for serv in self.dns_servers:
                print >>fp, "nameserver", serv
            fp.close()

        # If we're adding a new wireless interface to a working wired,
        # setup, dhclient will be happy to overwrite the existing working
        # resolv.conf with something new that's probably worse.
        # It also overwrites routing, but it's not clear
        # if there's anything we can do about that.
        # So try to keep it from writing.
        # XXX Ugh! This is awful -- is there a real solution?
        # Happily, dhcpcd actually allows control over this!
        # elif add:
        #     print "**** Trying to make resolv.conf unwritable"
        #     os.chmod("/etc/resolv.conf", 0444)
        #     os.system("chattr +i /etc/resolv.conf")
        #     #print >>fp, "pre-up chmod 444 /etc/resolv.conf"
        #     #print >>fp, "pre-up chattr +i /etc/resolv.conf"
        #     pass

        # Mark the interface up (and call ifup too, if applicable)
        subprocess.call(["ifconfig", self.iface.name, "up"])

        # This somehow ends up being the second time it's called.
        # So don't do that!
        if is_deb:
            # At one point I thought it was a good idea to call ifup
            # explicitly. But at least with some cards, ifup associates
            # with the accesspoint and calls DHCP -- all of which is
            # about to be done again from service networking restart.
            # And calling it the second time can fail (e.g. for Broadcom
            # BCM4313 where the driver needs to be reloaded before
            # each association).
            #subprocess.call(["ifup", self.iface.name])
            subprocess.call(["service", "networking", "restart"])

        # Try to make the routing tables sane:
        # in particular, if more than one interface is up, make sure
        # there's no wifi default route blocking on on a wired interface.
        up_ifaces = netutils.get_interfaces(True)
        print "Up interfaces now:", up_ifaces
        if len(up_ifaces) > 0:
            rt = netutils.Route.read_route_table()
            print "Route table:", rt
            defaults = []
            for r in rt:
                if r.dest == 'default' or r.dest == '0.0.0.0':
                    defaults.append(r)
                    print "Default route:", r
            print "============"
            if len(defaults) > 1:
                wired_route = None
                # Find the first wired route
                for r in defaults:
                    for iface in up_ifaces:
                        if r.iface == iface.name and not iface.wireless:
                            wired_route = r
                            print "  Wired route:", r
                            break
                if wired_route:
                    print "Using default route", wired_route
                    for r in defaults:
                        if r != wired_route:
                            print "Deleting route", r
                            r.delete()
        # if add:
        #     print "**** Making resolv.conf writable again"
        #     os.system("chattr -i /etc/resolv.conf")
        #     os.chmod("/etc/resolv.conf", 0644)
        #     #print >>fp, "post-up chmod 644 /etc/resolv.conf"
        #     #print >>fp, "post-up chattr -i /etc/resolv.conf"

        # At this point, we think the net is working.
        # But does it need a sign-on?
        # Alas, there's no universal page everyone can use.
        # So make one on your own website, or find a trusted page,
        # and put that URL in ~/.config/netscheme/testurl
        testurl = None
        testurlfile = os.path.join(NetScheme.configdir, "testurl")
        if os.path.exists(testurlfile):
            with open(testurlfile) as tufile:
                testurl = tufile.read().strip()
            with open(testurlfile + ".out") as tufile:
                testurl_content = tufile.read()
        if testurl:
            self.show_browser_if_redirect(testurl, testurl_content)
        else:
            print "No test URL set; not checking for redirects"

    def watch(self):
        '''Monitor the connection, and reset it if it drops.
        '''
        if not self.iface:
            return "Can't watch -- No interface set"
        while True:
            essid = self.iface.check_associated()
            if not essid:
                print "Looks like we've been dropped. Resetting ..."
                self.set_scheme()
            #else:
            #    print "ESSID is '%s'" % essid
            time.sleep(20)

def is_debian():
    # Strangely, the current status is that non-Debian networking
    # works better on Debian Squeeze, but doesn't work at all on
    # Ubuntu Pangolin. So on Ubuntu, we use debian, but on debian, we don't.
    try:
        lsb = open("/etc/lsb-release")
        print "Opened lsb-release"
        is_ubuntu = False
        release = 0
        for line in lsb:
            if line.startswith('DISTRIB_ID=Ubuntu'):
                is_ubuntu = True
            # elif line.startswith('DISTRIB_RELEASE='):
            #     release = float(line[16:])
        lsb.close()
        if is_ubuntu:
            print "Using Debian-style networking"
        else:
            print "Using standard networking, not Debian"
        return is_ubuntu
    except:
        print "Problem reading lsb-release, not debian"
        return False

    # We should never get here.
    return os.access("/etc/network/interfaces", os.R_OK)

def print_current_scheme():
    try:
        cur_fp = open(os.path.join(NetScheme.schemedirfile('current')))
        current_from_file = cur_fp.read().strip()
        cur_fp.close()
        print "Expected scheme:", current_from_file
    except:
        current_from_file = None

    ifaces = netutils.get_interfaces()
    for iface in ifaces:
        if not iface.is_up():
            continue

        print iface.name, ":",

        matchscheme = None
        for scheme in Schemes:
            if iface.wireless and iface.essid == scheme.essid:
                matchscheme = scheme.name
                break
            elif not iface.wireless and iface.ip == scheme.ip:
                matchscheme = scheme.name
                break
        if matchscheme:
            print "Netscheme", scheme.name
        else:
            print "(no netscheme found)"

        if iface.wireless:
            if iface.essid:
                print "  ESSID:", iface.essid
        if iface.ip:
            if matchscheme and scheme.dhcp:
                print "  IP:", iface.ip, "(dhcp)"
            else:
                print "  IP:", iface.ip
        if matchscheme and current_from_file and \
                scheme.name != current_from_file:
            print scheme.name, "didn't match expected scheme of", \
                current_from_file

def list_accesspoints(maxap=20):
    print "Scanning for available access points ..."
    while True:
        aplist = netutils.get_accesspoints()
        if aplist:
            break
        print "Couldn't scan for access points. Retrying ..."
        time.sleep(2)

    # Sort the list by ap.quality
    aplist.sort(cmp=lambda x,y: cmp(y.quality, x.quality))

    print "Visible access points:"
    for ap in aplist:
        # Show mode if it's anything but Master -- e.g. Ad-hoc
        mode = ''
        if ap.mode and ap.mode != 'Master':
            mode = ' (%s)' % ap.mode

        # Does it match a scheme we know about?
        schemestr = ''
        for scheme in Schemes:
            if ap.essid and ap.essid == scheme.essid:
                schemestr = '(%s)' % scheme.name

        print "%-22s: %-10s %-10s %s %s" % (ap.essid,
                                             ap.encryption,
                                             mode, ap.quality,
                                             schemestr)
        continue

def list_schemes():
    for scheme in Schemes:
        print scheme.name

def reset_current_scheme():
    # If we're using Debian networking, just reset whatever's
    # currently in /etc/network/interfaces.
    # However, that's a no-op in Ubuntu Pangolin (sigh!),
    # which currently is the only place we're actually using debian-style.
    if False and is_debian():
        subprocess.call(["service", "networking", "restart"])
        return

    # If not debian, reset the current scheme if there is one.
    cur_scheme_file = os.path.join(NetScheme.schemedirfile('current'))
    if not os.access(cur_scheme_file, os.R_OK):
        print "No current netscheme"
        return

    fp = open(cur_scheme_file)
    schemename = fp.readline().strip()
    fp.close()
    print "Resetting persistent scheme", schemename
    find_and_set_scheme(schemename, add=False, make_persistent=False)

def find_and_set_scheme(newscheme, add=False, make_persistent=False):

    # Whether we made a new scheme or used an old one,
    # if there's a persistent scheme specified and the user has specified
    # a different scheme, make sure we remove the "current" file first.
    current_file = NetScheme.schemedirfile('current')
    if os.path.exists(current_file):
        print "Removing old persistent scheme"
        os.remove(current_file)

    aplist = netutils.get_accesspoints()

    found = False

    for scheme in Schemes:
        if scheme.name != newscheme:
            continue

        # XXX TO DO: use python soundex module if available
        # to see if there's a similarly named scheme --
        # for instance, "Coffee Bean" instead of "coffeebean".

        # Found it; scheme is a NetScheme object.
        # But do we actually see the scheme available now, if it's wireless?
        # WE NEED TO set_scheme WHETHER OR NOT IT HAS AN ESSID!
        # BUT WAIT, THAT MAY NOT MATTER HERE SINCE CLINK DOES.
        if not scheme.essid:    # Not a wireless scheme, no need to search
            print "Setting scheme to", scheme.name
            scheme.set_scheme(add)
            found = True
            break
        # It's a wireless scheme. Did we see any accesspoints?
        if not aplist:
            print "No accesspoints visible.\n"
            found = False
            sys.exit(1)
        for ap in aplist:
            if ap.essid == scheme.essid:
                found = True
                break
        else:   
            found = True
        if found:
            scheme.set_scheme(add)
            break
        else:
            print "Existing scheme %s with essid %s not available here." % \
                (scheme.name, scheme.essid)

    if not found:
        # Didn't find an existing scheme: make a new one.
        print "No scheme named", newscheme

        for ap in aplist:
            if ap.essid == newscheme:
                # Sometimes we seem to get called a second time. Why?
                # traceback.print_stack()
    
                ans = raw_input("Use it anyway? (Y/n) ")
                if ans != 'y' and ans != 'Y' and ans != '':
                    sys.exit(1)

                # Get the key, if relevant:
                if ap.encryption and ap.encryption != "open":
                    key = raw_input("Password: ")
                else:
                    key = ''

                # Use the scheme
                scheme = NetScheme(ap.essid, True, encryption=ap.encryption,
                                   essid=ap.essid, key=key)
                if ap.interface:
                    scheme.interface = ap.interface

                # Save it (if requested) even before trying to set it,
                # so if setting the scheme fails, the user doesn't have
                # to keep typing 'y' and the password.
                # XXX (Of course, if it's failing because the password is
                # wrong, the only recourse is to edit the config file.)
                if make_persistent:
                    ans = 'y'
                else:
                    ans = raw_input("Save this scheme for later? (y/N) ")
                if ans == 'y' or ans == 'Y':
                    name = scheme.name
                    name = raw_input("Name for this scheme (%s): " % name)
                    name = name.strip()
                    if name:
                        scheme.name = name
                    scheme.save('.netscheme')

                scheme.set_scheme()

                # We've used a scheme, so don't continue looping through them.
                found = True
                break

    if not found:
        print "No scheme set"
        return None

    # If specified, make this the default scheme, used for netscheme -r
    # The file should already have been created and chowned if needed.
    if make_persistent:
        print "Trying to make this persistent"

        current_file = NetScheme.schemedirfile('current', True)

        # XXX Next test should be redundant -- hopefully we'll catch
        # creation errors in schemedirfile().
        if not os.path.exists(current_file):
            print "Eek, couldn't create", current_file
            return
        else:
            print current_file, "exists -- overwriting"

        print "Remembering current scheme %s to %s" \
            % (scheme.name, current_file)
        fp = open(current_file, "w")
        print >>fp, scheme.name
        fp.close()

    # Otherwise, if there's a default scheme and it's different
    # from the one we're switching to, clear it.
    elif os.access(current_file, os.R_OK & os.W_OK):
        fp = open(current_file)
        filescheme = fp.readline().strip()
        fp.close()
        if filescheme != newscheme:
            print "Removing persistent file", current_file
            os.remove(current_file)

    return scheme

#
# A couple of default schemes:
#
Schemes = [
    NetScheme("dhcp", True, encryption=None),    # wired
    NetScheme("wifi", True, encryption='open'),  # wireless
    ]

# main
if __name__ == "__main__":
    # Outer try clause to handle keyboard interrupts and not show
    # the user a nasty Python stack trace. Using signal.signal to
    # catch SIGINT doesn't work, perhaps because of the subprocesses
    # we need to call?
    try:
        from optparse import OptionParser
        usage = """Usage: %prog [-c [-s]] [scheme] | -l | -a | -r
    %prog changes your network (wi-fi) settings in /etc/network/interfaces.
    You can make named schemes, like "home" or "work", matching places you
    go frequently, or just make temporary schemes for places you visit briefly.
"""
        versionstr = """%prog 0.6: Set wireless network schemes.

Copyright 2010-2016 by Akkana Peck; share and enjoy under the GPL v.2 or later."""
        parser = OptionParser(usage=usage, version=versionstr)
        parser.add_option("-l", "--list",
                          action="store_true", dest="list_schemes",
                          default=False,
                          help="List the known schemes")
        parser.add_option("-a", "--accesspoints",
                          action="store_true", dest="list_accesspoints",
                          default=False,
                          help="List available accesspoints")
        parser.add_option("-r", "--reset",
                          action="store_true", dest="reset_current_scheme",
                          default=False,
                          help="Reset the connection without changing scheme")
        parser.add_option("-p", "--persistent",
                          action="store_true", dest="make_persistent",
                          default=False,
                          help="Make this scheme persistent (used in netscheme -r)")
        parser.add_option("-w", "--watch",
                          action="store_true", dest="watch",
                          default=False,
                          help="Watch the interface and reset it if it drops")
        parser.add_option("-m", "--multi",
                          action="store_true", dest="multi",
                          default=False,
                          help="Multiple interfaces: add a new interface without bringing down current one")
        parser.add_option("-s", "--save",
                          action="store_true", dest="save_new_scheme",
                          default=False,
                          help="Reset the connection without changing scheme")
        # parser.add_option("-c", "--create", metavar="new-SSID",
        #                   action="store", dest="newscheme",
        #                   help="Create a new scheme (temporary unless -s is also set)")
        (options, args) = parser.parse_args()

        ###################################################
        # Read in a list of NetSchemes from the config file
        config = ConfigParser({'dhcp':False, 'ip':'',
                               'netmask':'', 'broadcast':'', 'gateway':'',
                               'encryption':'', 'essid':'', 'key':'',
                               'interface':'', 'dns_servers':''})

            
        configfile = NetScheme.schemedirfile('.netscheme')
        print "Reading configurations from", configfile
        config.read(configfile)

        for scheme in config.sections():
            newscheme = NetScheme(name = scheme,
                                  dhcp = config.getboolean(scheme, 'dhcp'),
                                  ip = config.get(scheme, 'ip'),
                                  netmask = config.get(scheme, 'netmask'),
                                  broadcast = config.get(scheme, 'broadcast'),
                                  gateway = config.get(scheme, 'gateway'),
                                  encryption = config.get(scheme,
                                                          'encryption'),
                                  essid = config.get(scheme, 'essid'),
                                  key = config.get(scheme, 'key'),
                                  dns_servers = config.get(scheme,
                                                           'dns_servers') \
                                                                 .split(','))
            newscheme.interface = config.get(scheme, 'interface')
            Schemes.append(newscheme)

        if (options.list_accesspoints):
            list_accesspoints()
            sys.exit(0)

        # Schemes are read, options are read, time to do stuff.
        if (options.list_schemes):
            list_schemes()
        elif (options.reset_current_scheme):
            reset_current_scheme()
        elif len(args) < 1:
            #print parser.usage
            print_current_scheme()
        else:
            try:
                scheme = find_and_set_scheme(args[0], options.multi,
                                       make_persistent=options.make_persistent)

                # If "watch" is on, fork and watch the connection in the
                # background, resetting it when necessary:
                if options.watch:
                    if os.fork():
                        sys.exit(0)
                    else:
                        scheme.watch()

            except OSError:
                print "Couldn't set scheme"
    except KeyboardInterrupt:
        print "Interrupt"
